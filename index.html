<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>BVB Portfolio Tracker</title>
    <link rel="stylesheet" href="styles.css?v=2025-12-23-1" />
    <script>
        (function () {
            const V = "2025-12-23-1";
            const url = new URL(window.location.href);
            if (!url.searchParams.has("v")) {
                url.searchParams.set("v", V);
                window.location.replace(url.toString());
            }
        })();
    </script>
    <style>
        input[readonly]{background-color:#eee;color:#666;cursor:not-allowed}
        .muted{font-size:13px;color:#666}
        .spacer-8{height:8px}.spacer-16{height:16px}.spacer-24{height:24px}
        .section{margin-bottom:18px}
        .row-actions{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
        .btn-secondary{background-color:#6c63ff;color:#fff;padding:10px 14px;border-radius:6px;cursor:pointer;border:none;width:auto}
        .card-like{border:1px solid #ddd;border-radius:10px;background:#fff;padding:14px}
        textarea.tradeville-input{
            width:100%;min-height:160px;resize:vertical;padding:10px;border:1px solid #ccc;border-radius:8px;
            font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
            font-size:12px;line-height:1.4;background:#fff
        }
        .small-table td,.small-table th{padding:8px}
        .right{text-align:right}.center{text-align:center}

        .badge{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:999px;font-size:12px;line-height:1;border:1px solid transparent;user-select:none;white-space:nowrap}
        .badge-success{background:rgba(46,160,67,.12);color:#2ea043;border-color:rgba(46,160,67,.25)}
        .status-row{display:flex;flex-direction:column;align-items:flex-start;gap:6px;margin-top:8px}

        .segmented{display:inline-flex;border:1px solid rgba(108,99,255,.35);border-radius:999px;overflow:hidden;background:transparent;height:38px}
        .segmented input{position:absolute;opacity:0;pointer-events:none}
        .segmented label{display:inline-flex;align-items:center;justify-content:center;padding:0 14px;height:38px;font-size:13px;cursor:pointer;color:#6c63ff;user-select:none;white-space:nowrap;background:rgba(108,99,255,.10);box-sizing:border-box}
        .segmented label+label{border-left:1px solid rgba(108,99,255,.25)}
        .segmented label.active{background:#6c63ff;color:#fff}

        .collapse-wrap{overflow:hidden;transition:max-height 220ms ease,opacity 220ms ease,transform 220ms ease;opacity:1;transform:translateY(0);max-height:2000px}
        .collapse-wrap.is-hidden{max-height:0;opacity:0;transform:translateY(-6px);pointer-events:none}

        details.import-details{border:1px solid #ddd;border-radius:10px;background:#fff;padding:10px 12px}
        details.import-details>summary{cursor:pointer;list-style:none;display:flex;align-items:center;justify-content:space-between;gap:12px;font-weight:600}
        details.import-details>summary::-webkit-details-marker{display:none}
        .summary-hint{font-weight:400;color:#666;font-size:12px}
        .chev{width:10px;height:10px;border-right:2px solid rgba(0,0,0,.45);border-bottom:2px solid rgba(0,0,0,.45);transform:rotate(45deg);transition:transform 160ms ease;margin-left:8px;flex:0 0 auto}
        details[open] .chev{transform:rotate(225deg)}

        .yn{display:flex;align-items:center;justify-content:flex-start;gap:12px;flex-wrap:wrap}
        .yn-label{font-weight:600}
        .yn-switch{display:inline-flex;border-radius:999px;overflow:hidden;border:1px solid rgba(108,99,255,.35);background:rgba(108,99,255,.10)}
        .yn-switch button{border:0;padding:8px 14px;cursor:pointer;font-size:13px;color:#6c63ff;background:transparent;transition:background 160ms ease,color 160ms ease;min-width:54px}
        .yn-switch button+button{border-left:1px solid rgba(108,99,255,.25)}
        .yn-switch button.active{background:#6c63ff;color:#fff}
        .yn-hidden-checkbox{position:absolute;opacity:0;pointer-events:none}
        .yn-row{margin-top:10px}

        .mini-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
        @media (max-width:760px){.mini-grid{grid-template-columns:1fr}}
        .kv{display:flex;flex-direction:column;gap:4px}
        .kv .k{font-size:12px;color:#666}
        .kv .v{font-size:14px;color:#222;font-weight:600}

        .pill{display:inline-flex;align-items:center;padding:4px 12px;border-radius:999px;font-size:12px;font-weight:800;border:1px solid rgba(0,0,0,.12);background:rgba(0,0,0,.06);color:#222;width:fit-content}
        .pill.PLATINUM{background:rgba(30,30,30,.12);border-color:rgba(30,30,30,.25);color:#1e1e1e}
        .pill.GOLD{background:rgba(242,193,78,.22);border-color:rgba(242,193,78,.45);color:#7a5a00}
        .pill.SILVER{background:rgba(176,176,176,.22);border-color:rgba(176,176,176,.45);color:#4a4a4a}
        .pill.BRONZE{background:rgba(199,124,46,.22);border-color:rgba(199,124,46,.45);color:#6a3f12}
        .pill.STANDARD{background:rgba(91,126,166,.22);border-color:rgba(91,126,166,.45);color:#2e4f73}

        .fee-big{font-size:18px;font-weight:800;color:#222}
        .fee-sub{font-size:12px;color:#666;margin-top:2px}
        .suggestion-details{margin-top:8px;font-size:12px;color:#666}
        .neg{color:#b42318;font-weight:700}
    </style>
</head>
<body>

<div class="top-nav">
    <div class="top-nav-inner">
        <div class="top-nav-title">BVB Index Distribution</div>
        <div class="top-nav-tabs">
            <a class="top-nav-tab active" href="index.html?v=2025-12-23-1">Tracker</a>
            <a class="top-nav-tab" href="about.html?v=2025-12-23-1">About</a>
            <a class="top-nav-tab" href="data.html?v=2025-12-23-1">Data Coverage</a>
            <a class="top-nav-tab" href="allocation.html?v=2025-12-23-1">Allocation History</a>
        </div>
    </div>
</div>

<h2>BVB Portfolio Tracker</h2>

<div class="container">

    <div class="file-input section">
        <label>BVB Companies CSV</label>
        <div class="file-wrapper" style="justify-content: space-between;">
      <span class="file-name" id="bvbSourceStatus">
        Using latest from repository: <b>bvb-companies-latest.csv</b>
      </span>
            <a href="input/bvb_distribution/bvb-companies-latest.csv" class="file-label"
               style="text-decoration:none;display:inline-block;" target="_blank" rel="noopener noreferrer">
                Open latest
            </a>
        </div>

        <div class="status-row">
            <div class="muted">Status: <span id="bvbLoadStatus">Will be loaded on Generate Report</span></div>
            <span id="bvbRowsBadge" class="badge badge-success" style="display:none;"></span>
        </div>
    </div>

    <div class="section">
        <label>Portfolio import</label>

        <div style="margin-top:8px;">
            <div class="segmented" id="importSegmented">
                <input type="radio" name="importMode" id="importModeCsv" value="csv" checked />
                <label for="importModeCsv" id="segCsv" class="active">CSV upload</label>

                <input type="radio" name="importMode" id="importModePaste" value="paste" />
                <label for="importModePaste" id="segPaste">Tradeville copy/paste</label>
            </div>
        </div>

        <div class="spacer-16"></div>

        <div id="csvImportBlock" class="collapse-wrap">
            <div class="file-input">
                <label for="portfolioFile">Upload Current Portfolio CSV (symbol,value,market_price)</label>
                <div class="file-wrapper">
                    <label for="portfolioFile" class="file-label">Choose file</label>
                    <input type="file" id="portfolioFile" accept=".csv,.txt" />
                    <span class="file-name" id="portfolioFileName">No file chosen</span>
                </div>

                <div style="margin-top:8px;" class="muted">
                    Expected headers: <b>symbol,value,market_price</b>.
                    <br/>
                    Use <b>CASH_VALUE</b> row for available cash (e.g. <code>CASH_VALUE,12023.80,</code>).
                </div>

                <div class="status-row">
                    <div class="muted">Detected: <span id="portfolioParseStatus">No file loaded</span></div>
                    <span id="portfolioRowsBadge" class="badge badge-success" style="display:none;"></span>
                </div>
            </div>
        </div>

        <div id="pasteImportBlock" class="collapse-wrap is-hidden">
            <div class="card-like">
                <div class="muted" style="margin-bottom:8px;">
                    Paste the Tradeville portfolio table here. Extra text before/after is fine.
                    The parser extracts: <b>Pret piata</b> as <b>market_price</b>, <b>evaluare</b> as <b>value</b>,
                    and detects cash from the <b>RON</b> row.
                </div>

                <textarea id="tradevilleText" class="tradeville-input" placeholder="Paste Tradeville table text here..."></textarea>

                <div class="spacer-8"></div>

                <div class="row-actions">
                    <button id="parseTradevilleBtn" class="btn-secondary" type="button">Parse pasted text</button>
                </div>

                <div class="status-row">
                    <div class="muted">Detected: <span id="tradevilleParseStatus">No pasted data</span></div>
                    <span id="tradevilleRowsBadge" class="badge badge-success" style="display:none;"></span>
                </div>
            </div>
        </div>
    </div>

    <div id="importPreviewBlock" class="section" style="display:none;">
        <details class="import-details" id="importPreviewDetails">
            <summary>
        <span>
          Imported portfolio values
          <span class="summary-hint" id="importPreviewHint">· click to expand</span>
        </span>
                <span style="display:inline-flex; align-items:center; gap:10px;">
          <span id="importPreviewRowsBadge" class="badge badge-success" style="display:none;"></span>
          <span class="chev" aria-hidden="true"></span>
        </span>
            </summary>

            <div class="spacer-8"></div>
            <div class="muted" style="margin-bottom:10px;">
                Normalized input used for report generation (stocks-only weights; CASH_VALUE excluded from weights).
            </div>
            <div id="importPreviewTable"></div>
        </details>
    </div>

    <div class="input-group section">
        <label for="totalInvestment">Total Portfolio Value (stocks-only, auto from import)</label>
        <input type="number" id="totalInvestment" placeholder="Auto-filled from portfolio import" readonly />
        <div style="margin-top:6px;" class="muted">
            This excludes CASH_VALUE so cash won’t influence stock weights.
        </div>
    </div>

    <div class="section yn yn-row">
        <span class="yn-label">Only consider companies in my portfolio</span>
        <input type="checkbox" id="filterPortfolioToggle" class="yn-hidden-checkbox" checked />
        <div class="yn-switch" role="group" aria-label="Only consider companies in my portfolio">
            <button type="button" id="filterYes" class="active">Yes</button>
            <button type="button" id="filterNo">No</button>
        </div>
        <div class="muted" style="width:100%; margin-top:6px;">
            If enabled, the index is normalized only over the symbols that exist in your imported portfolio.
        </div>
    </div>

    <div class="section yn yn-row">
        <span class="yn-label">Enable New Investment</span>
        <input type="checkbox" id="newInvestmentToggle" class="yn-hidden-checkbox" />
        <div class="yn-switch" role="group" aria-label="Enable New Investment">
            <button type="button" id="investYes">Yes</button>
            <button type="button" id="investNo" class="active">No</button>
        </div>
        <div class="muted" style="width:100%; margin-top:6px;">
            If enabled, the tool suggests buy-only allocations using CASH_VALUE as the available cash.
        </div>
    </div>

    <div id="investmentFields" style="display:none;" class="section">
        <div class="input-group">
            <label for="newInvestmentAmount">New Investment Amount (auto from CASH_VALUE)</label>
            <input type="number" id="newInvestmentAmount" placeholder="Enter new investment amount" />
        </div>

        <div class="input-group">
            <label for="minInvestmentAmount">Minimum Investment per Stock</label>
            <input type="number" id="minInvestmentAmount" placeholder="Enter minimum investment per stock" value="500" />
        </div>

        <div class="muted">
            Suggestions are computed buy-only (no selling). Market prices are used for better practicality.
        </div>
        <div class="spacer-16"></div>
    </div>

    <button id="generateReport">Generate Report</button>

    <div class="report-container">
        <div id="report"></div>
        <div id="investmentSuggestions"></div>

        <div id="feeTierBlock" class="section" style="display:none;">
            <div class="card-like">
                <div style="font-weight:700; color:#222;">TradeVille fee tier (BVB, estimated)</div>

                <div class="spacer-8"></div>
                <div><span class="pill" id="feeTierName">—</span></div>

                <div class="spacer-16"></div>

                <div class="fee-big" id="feeTierFeesBig">—</div>
                <div class="fee-sub" id="feeTierFeesSub"></div>

                <div class="spacer-16"></div>

                <div class="kv" style="margin-bottom:10px;">
                    <div class="k">Tier rule</div>
                    <div class="v" id="feeTierRule">—</div>
                </div>

                <div class="spacer-16"></div>

                <div class="mini-grid">
                    <div class="kv"><div class="k">Portfolio total (RON)</div><div class="v" id="feePortfolioRon">—</div></div>
                    <div class="kv"><div class="k">EUR/RON</div><div class="v" id="feeEurRon">—</div></div>
                    <div class="kv"><div class="k">Portfolio total (EUR)</div><div class="v" id="feePortfolioEur">—</div></div>
                    <div class="kv"><div class="k">Updated</div><div class="v" id="feeTierUpdated">—</div></div>
                </div>

                <div class="spacer-8"></div>
                <div class="muted" id="feeTierSources"></div>

                <div class="spacer-8"></div>
                <div class="muted">
                    Notes: Tier selection uses total portfolio value (stocks + cash). Fees are estimates and stored as a static snapshot.
                </div>
            </div>
        </div>

        <div id="afterSuggestions"></div>
    </div>
</div>

<script>
    const BVB_LATEST_CSV_URL = "input/bvb_distribution/bvb-companies-latest.csv";
    const EUR_RON_JSON_URL = "input/meta/eur_ron.json";
    const TRADEVILLE_FEES_JSON_URL = "input/meta/tradeville_fees_ro_bvb.json";

    const bvbLoadStatusEl = document.getElementById("bvbLoadStatus");
    const portfolioParseStatusEl = document.getElementById("portfolioParseStatus");
    const tradevilleParseStatusEl = document.getElementById("tradevilleParseStatus");
    const totalInvestmentEl = document.getElementById("totalInvestment");
    const newInvestmentAmountEl = document.getElementById("newInvestmentAmount");

    const importPreviewBlockEl = document.getElementById("importPreviewBlock");
    const importPreviewTableEl = document.getElementById("importPreviewTable");

    const bvbRowsBadgeEl = document.getElementById("bvbRowsBadge");
    const portfolioRowsBadgeEl = document.getElementById("portfolioRowsBadge");
    const tradevilleRowsBadgeEl = document.getElementById("tradevilleRowsBadge");
    const importPreviewRowsBadgeEl = document.getElementById("importPreviewRowsBadge");

    const feeTierBlockEl = document.getElementById("feeTierBlock");
    const feeTierNameEl = document.getElementById("feeTierName");
    const feeTierFeesBigEl = document.getElementById("feeTierFeesBig");
    const feeTierFeesSubEl = document.getElementById("feeTierFeesSub");
    const feeTierSourcesEl = document.getElementById("feeTierSources");
    const feePortfolioRonEl = document.getElementById("feePortfolioRon");
    const feeEurRonEl = document.getElementById("feeEurRon");
    const feePortfolioEurEl = document.getElementById("feePortfolioEur");
    const feeTierRuleEl = document.getElementById("feeTierRule");
    const feeTierUpdatedEl = document.getElementById("feeTierUpdated");

    let parsedPortfolio = null;
    let metaEurRon = null;
    let metaFees = null;

    const importModeCsvEl = document.getElementById("importModeCsv");
    const importModePasteEl = document.getElementById("importModePaste");
    const csvImportBlockEl = document.getElementById("csvImportBlock");
    const pasteImportBlockEl = document.getElementById("pasteImportBlock");

    const segCsvEl = document.getElementById("segCsv");
    const segPasteEl = document.getElementById("segPaste");

    function setSegmentActive(isCsv) {
        segCsvEl.classList.toggle("active", isCsv);
        segPasteEl.classList.toggle("active", !isCsv);
    }

    function setImportMode(mode) {
        const isCsv = mode === "csv";
        setSegmentActive(isCsv);
        csvImportBlockEl.classList.toggle("is-hidden", !isCsv);
        pasteImportBlockEl.classList.toggle("is-hidden", isCsv);

        if (isCsv) {
            tradevilleParseStatusEl.textContent = "No pasted data";
            tradevilleRowsBadgeEl.style.display = "none";
        } else {
            portfolioParseStatusEl.textContent = "No file loaded";
            portfolioRowsBadgeEl.style.display = "none";
            document.getElementById("portfolioFileName").textContent = "No file chosen";
            document.getElementById("portfolioFile").value = "";
        }
    }

    importModeCsvEl.addEventListener("change", () => setImportMode("csv"));
    importModePasteEl.addEventListener("change", () => setImportMode("paste"));

    const filterToggleEl = document.getElementById("filterPortfolioToggle");
    const filterYesBtn = document.getElementById("filterYes");
    const filterNoBtn = document.getElementById("filterNo");
    function syncFilterButtons() {
        const on = !!filterToggleEl.checked;
        filterYesBtn.classList.toggle("active", on);
        filterNoBtn.classList.toggle("active", !on);
    }
    filterYesBtn.addEventListener("click", () => { filterToggleEl.checked = true; syncFilterButtons(); });
    filterNoBtn.addEventListener("click", () => { filterToggleEl.checked = false; syncFilterButtons(); });
    syncFilterButtons();

    const newInvToggleEl = document.getElementById("newInvestmentToggle");
    const investYesBtn = document.getElementById("investYes");
    const investNoBtn = document.getElementById("investNo");
    function syncInvestmentButtons() {
        const on = !!newInvToggleEl.checked;
        investYesBtn.classList.toggle("active", on);
        investNoBtn.classList.toggle("active", !on);
        document.getElementById("investmentFields").style.display = on ? "block" : "none";
    }
    investYesBtn.addEventListener("click", () => { newInvToggleEl.checked = true; syncInvestmentButtons(); });
    investNoBtn.addEventListener("click", () => { newInvToggleEl.checked = false; syncInvestmentButtons(); });
    newInvToggleEl.addEventListener("change", syncInvestmentButtons);
    syncInvestmentButtons();

    document.getElementById("portfolioFile").addEventListener("change", function () {
        const file = this.files[0];
        document.getElementById("portfolioFileName").textContent = file ? file.name : "No file chosen";

        parsedPortfolio = null;
        portfolioParseStatusEl.textContent = "Parsing...";
        portfolioRowsBadgeEl.style.display = "none";
        importPreviewRowsBadgeEl.style.display = "none";

        totalInvestmentEl.value = "";
        newInvestmentAmountEl.value = "";
        hideImportPreview();
        hideFeeTierSection();

        if (!file) {
            portfolioParseStatusEl.textContent = "No file loaded";
            return;
        }

        const reader = new FileReader();
        reader.onload = function (event) {
            try {
                const rows = parseCSV(event.target.result);
                const hasSymbol = rows.length > 0 && Object.prototype.hasOwnProperty.call(rows[0], "symbol");
                const hasValue  = rows.length > 0 && Object.prototype.hasOwnProperty.call(rows[0], "value");
                const hasPrice  = rows.length > 0 && Object.prototype.hasOwnProperty.call(rows[0], "market_price");
                if (!hasSymbol || !hasValue || !hasPrice) throw new Error("Portfolio CSV must contain headers: symbol,value,market_price");

                const { portfolio, totalStocksValue, cashValue, totalAllValue, rawStocks } = portfolioValues(rows);
                parsedPortfolio = { portfolio, totalStocksValue, cashValue, totalAllValue, rawStocks, source: "csv" };

                totalInvestmentEl.value = totalStocksValue.toFixed(2);
                if (cashValue > 0) {
                    newInvestmentAmountEl.value = cashValue.toFixed(2);
                    portfolioParseStatusEl.textContent = `Loaded ✅ (stocks: ${totalStocksValue.toFixed(2)}, CASH_VALUE: ${cashValue.toFixed(2)})`;
                } else {
                    portfolioParseStatusEl.textContent = `Loaded ✅ (stocks: ${totalStocksValue.toFixed(2)}, no CASH_VALUE row found)`;
                }

                const totalRows = (rawStocks?.length || 0) + (cashValue > 0 ? 1 : 0);
                portfolioRowsBadgeEl.textContent = `Loaded (${totalRows} rows)`;
                portfolioRowsBadgeEl.style.display = "inline-flex";

                renderImportPreview(parsedPortfolio);
            } catch (e) {
                console.error(e);
                portfolioParseStatusEl.textContent = "Failed ❌";
                portfolioRowsBadgeEl.style.display = "none";
                alert(`Could not parse portfolio CSV: ${e.message}`);
            }
        };
        reader.readAsText(file);
    });

    document.getElementById("parseTradevilleBtn").addEventListener("click", function () {
        const text = String(document.getElementById("tradevilleText").value || "").trim();

        parsedPortfolio = null;
        tradevilleParseStatusEl.textContent = "Parsing...";
        tradevilleRowsBadgeEl.style.display = "none";
        importPreviewRowsBadgeEl.style.display = "none";

        totalInvestmentEl.value = "";
        newInvestmentAmountEl.value = "";
        hideImportPreview();
        hideFeeTierSection();

        if (!text) {
            tradevilleParseStatusEl.textContent = "No pasted data";
            return;
        }

        try {
            const rows = parseTradevilleToRows(text);
            if (!rows || rows.length === 0) throw new Error("No usable instrument rows found. Make sure you pasted the Tradeville table.");

            const { portfolio, totalStocksValue, cashValue, totalAllValue, rawStocks } = portfolioValues(rows);
            parsedPortfolio = { portfolio, totalStocksValue, cashValue, totalAllValue, rawStocks, source: "tradeville" };

            totalInvestmentEl.value = totalStocksValue.toFixed(2);
            if (cashValue > 0) {
                newInvestmentAmountEl.value = cashValue.toFixed(2);
                tradevilleParseStatusEl.textContent = `Loaded ✅ (stocks: ${totalStocksValue.toFixed(2)}, CASH_VALUE: ${cashValue.toFixed(2)})`;
            } else {
                tradevilleParseStatusEl.textContent = `Loaded ✅ (stocks: ${totalStocksValue.toFixed(2)}, no RON/CASH line detected)`;
            }

            const totalRows = (rawStocks?.length || 0) + (cashValue > 0 ? 1 : 0);
            tradevilleRowsBadgeEl.textContent = `Loaded (${totalRows} rows)`;
            tradevilleRowsBadgeEl.style.display = "inline-flex";

            renderImportPreview(parsedPortfolio);
        } catch (e) {
            console.error(e);
            tradevilleParseStatusEl.textContent = "Failed ❌";
            tradevilleRowsBadgeEl.style.display = "none";
            alert(`Could not parse pasted Tradeville data: ${e.message}`);
        }
    });

    document.getElementById("generateReport").addEventListener("click", async function () {
        if (!parsedPortfolio) {
            alert("Please import your portfolio first (CSV upload or Tradeville copy/paste).");
            return;
        }

        const onlyPortfolioCompanies = document.getElementById("filterPortfolioToggle").checked;

        const totalStocksValue = Number(totalInvestmentEl.value);
        if (!Number.isFinite(totalStocksValue) || totalStocksValue <= 0) {
            alert("Total Portfolio Value (stocks-only) is missing or invalid.");
            return;
        }

        const newInvestmentEnabled = document.getElementById("newInvestmentToggle").checked;
        const newInvestment = newInvestmentEnabled ? Number(document.getElementById("newInvestmentAmount").value) : 0;
        const minInvestmentAmount = newInvestmentEnabled ? Number(document.getElementById("minInvestmentAmount").value) : 0;

        if (newInvestmentEnabled && (!Number.isFinite(newInvestment) || newInvestment <= 0)) {
            alert("Please enter a valid New Investment Amount.");
            return;
        }
        if (newInvestmentEnabled && (!Number.isFinite(minInvestmentAmount) || minInvestmentAmount < 0)) {
            alert("Please enter a valid Minimum Investment per Stock.");
            return;
        }

        bvbLoadStatusEl.textContent = "Loading...";
        bvbRowsBadgeEl.style.display = "none";

        let bvbText;
        try {
            const cacheBuster = `t=${Date.now()}`;
            const resp = await fetch(`${BVB_LATEST_CSV_URL}?${cacheBuster}`, { cache: "no-store" });
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            bvbText = await resp.text();
            bvbLoadStatusEl.textContent = "Loaded ✅";
        } catch (e) {
            console.error(e);
            bvbLoadStatusEl.textContent = "Failed ❌";
            alert("Could not load the latest BVB companies file from the repository.");
            return;
        }

        const bvbData = parseCSV(bvbText);
        const bvbCount = Array.isArray(bvbData) ? bvbData.filter(r => r && r.symbol).length : 0;
        bvbRowsBadgeEl.textContent = `Loaded (${bvbCount} rows)`;
        bvbRowsBadgeEl.style.display = "inline-flex";

        await loadFeeMetaIfNeeded();

        generateReportAndSuggestions(
            bvbData,
            parsedPortfolio.portfolio,
            parsedPortfolio.totalStocksValue,
            parsedPortfolio.totalAllValue,
            onlyPortfolioCompanies,
            newInvestmentEnabled ? newInvestment : 0,
            newInvestmentEnabled ? minInvestmentAmount : 0
        );
    });

    async function loadFeeMetaIfNeeded() {
        if (metaEurRon && metaFees) return;
        metaEurRon = null;
        metaFees = null;

        try {
            const cacheBuster = `t=${Date.now()}`;
            const [eurResp, feeResp] = await Promise.all([
                fetch(`${EUR_RON_JSON_URL}?${cacheBuster}`, { cache: "no-store" }),
                fetch(`${TRADEVILLE_FEES_JSON_URL}?${cacheBuster}`, { cache: "no-store" })
            ]);
            if (eurResp.ok) metaEurRon = await eurResp.json();
            if (feeResp.ok) metaFees = await feeResp.json();
        } catch (e) {
            console.warn("Failed to load fee meta json:", e);
            metaEurRon = null;
            metaFees = null;
        }
    }

    function pickTier(totalEur, feesJson) {
        const tiers = Array.isArray(feesJson?.tiers) ? feesJson.tiers.slice() : [];
        tiers.sort((a, b) => (b.threshold_eur_min ?? 0) - (a.threshold_eur_min ?? 0));
        for (const t of tiers) {
            const thr = Number(t.threshold_eur_min ?? 0);
            if (totalEur >= thr) return t;
        }
        return tiers[tiers.length - 1] || null;
    }

    function renderFeeTierSection(totalRon, eurJson, feesJson) {
        const eurRon = Number(eurJson?.eur_ron);
        if (!Number.isFinite(eurRon) || eurRon <= 0) throw new Error("Invalid EUR/RON rate");

        const totalEur = totalRon / eurRon;
        const tier = pickTier(totalEur, feesJson);
        if (!tier) throw new Error("No tier found");

        const thr = Number(tier.threshold_eur_min ?? 0);
        const feePct = Number(tier.fee_percent ?? 0);
        const fixedEur = Number(tier.fixed_fee_eur ?? 0);

        feeTierNameEl.textContent = tier.name || "—";
        feeTierNameEl.className = `pill ${(tier.name || "").toUpperCase()}`;

        feeTierFeesBigEl.textContent = `${feePct.toFixed(2)}% + €${fixedEur.toFixed(2)}`;
        feeTierFeesSubEl.textContent = `All Inclusive commission for BVB (estimate)`;

        feeTierRuleEl.textContent = `≥ ${formatMoney(thr)} EUR`;

        const eurUpdated = eurJson?.updated_at_utc ? String(eurJson.updated_at_utc) : "—";
        const feesUpdated = feesJson?.updated_at_utc ? String(feesJson.updated_at_utc) : "—";

        feeTierSourcesEl.innerHTML = `
      Sources:
      <a href="${TRADEVILLE_FEES_JSON_URL}" target="_blank" rel="noopener noreferrer">tradeville_fees_ro_bvb.json</a>
      ·
      <a href="${EUR_RON_JSON_URL}" target="_blank" rel="noopener noreferrer">eur_ron.json</a>
    `;

        feePortfolioRonEl.textContent = formatMoney(totalRon) + " RON";
        feeEurRonEl.textContent = eurRon + ` (observed: ${eurJson?.observed_date_text || "—"})`;
        feePortfolioEurEl.textContent = formatMoney(totalEur) + " EUR";
        feeTierUpdatedEl.textContent = `fees: ${feesUpdated} · eur: ${eurUpdated}`;

        feeTierBlockEl.style.display = "block";
    }

    function hideFeeTierSection() {
        feeTierBlockEl.style.display = "none";
        feeTierNameEl.textContent = "—";
        feeTierNameEl.className = "pill";
        feeTierFeesBigEl.textContent = "—";
        feeTierFeesSubEl.textContent = "";
    }

    function hideImportPreview() {
        importPreviewBlockEl.style.display = "none";
        importPreviewTableEl.innerHTML = "";
        importPreviewRowsBadgeEl.style.display = "none";
    }

    // IMPORTANT: Do not round market_price in the UI either
    function renderImportPreview(state) {
        if (!state) return;

        const stockRows = (state.rawStocks || []).slice().sort((a, b) => b.value - a.value);
        const cash = state.cashValue || 0;

        const rowsHtml = stockRows.map(r => {
            const weight = (r.value / state.totalStocksValue) * 100;
            return `
        <tr>
          <td class="center">${escapeHtml(r.symbol)}</td>
          <td class="right">${r.value.toFixed(2)}</td>
          <td class="right">${r.market_price}</td>
          <td class="right">${weight.toFixed(2)}%</td>
        </tr>
      `;
        }).join("");

        const cashRowHtml = cash > 0 ? `
      <tr>
        <td class="center">CASH_VALUE</td>
        <td class="right">${cash.toFixed(2)}</td>
        <td class="right muted">—</td>
        <td class="right muted">excluded</td>
      </tr>
    ` : "";

        importPreviewTableEl.innerHTML = `
      <table class="small-table">
        <tr>
          <th>Symbol</th>
          <th>Value</th>
          <th>Market price</th>
          <th>Weight (stocks-only)</th>
        </tr>
        ${rowsHtml}
        ${cashRowHtml}
      </table>
    `;

        const totalRows = stockRows.length + (cash > 0 ? 1 : 0);
        importPreviewRowsBadgeEl.textContent = `Loaded (${totalRows} rows)`;
        importPreviewRowsBadgeEl.style.display = "inline-flex";
        importPreviewBlockEl.style.display = "block";
    }

    function escapeHtml(s) {
        return String(s)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");
    }

    function formatMoney(n) {
        return Number(n).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }

    // ---- Tradeville parsing helpers (as before) ----
    function parseTradevilleToRows(text) {
        const lines = String(text)
            .replace(/\r\n/g, "\n")
            .replace(/\r/g, "\n")
            .split("\n")
            .map(l => l.trim())
            .filter(l => l.length > 0);

        const out = [];
        let detectedCash = null;

        for (const line of lines) {
            const normalized = line.replace(/\u00A0/g, " ");
            const parts = splitLooseColumns(normalized);
            if (parts.length < 4) continue;

            if (parts[0].toUpperCase() === "RON") {
                const cash = findBestCashLike(parts);
                if (Number.isFinite(cash) && cash > 0) detectedCash = cash;
                continue;
            }

            const sym = parts[0].trim();
            if (!/^[A-Z0-9]{1,6}$/.test(sym)) continue;

            const lastToken = String(parts[parts.length - 1] || "");
            if (!/%$/.test(lastToken)) continue;

            const evaluare = findEvaluareFromEnd(parts);
            if (!Number.isFinite(evaluare) || evaluare <= 0) continue;

            const marketPrice = findMarketPriceNearQuantity(parts);
            if (!Number.isFinite(marketPrice) || marketPrice <= 0) continue;

            out.push({ symbol: sym, value: evaluare, market_price: marketPrice });
        }

        if (Number.isFinite(detectedCash) && detectedCash > 0) {
            out.push({ symbol: "CASH_VALUE", value: detectedCash, market_price: "" });
        }

        const merged = new Map();
        for (const r of out) {
            const k = String(r.symbol).trim();
            if (!k) continue;

            const prev = merged.get(k);
            if (!prev) {
                merged.set(k, { symbol: k, value: Number(r.value) || 0, market_price: r.market_price });
            } else {
                prev.value += (Number(r.value) || 0);
                if (Number.isFinite(Number(r.market_price)) && Number(r.market_price) > 0) {
                    prev.market_price = r.market_price;
                }
            }
        }

        return Array.from(merged.values());
    }

    function splitLooseColumns(line) {
        if (line.includes("\t")) return line.split("\t").map(s => s.trim()).filter(s => s !== "");
        return line.split(/\s{2,}/g).map(s => s.trim()).filter(s => s !== "");
    }

    function parseMoney(raw) {
        if (raw == null) return NaN;
        let s = String(raw).trim();
        s = s.replace(/[A-Za-z]/g, "").trim();
        s = s.replace(/%/g, "").trim();
        s = s.replace(/\s/g, "");
        if (/^\d{1,3}(,\d{3})+(\.\d+)?$/.test(s)) s = s.replace(/,/g, "");
        if (/^\d+,\d+$/.test(s)) s = s.replace(",", ".");
        const n = Number(s);
        return Number.isFinite(n) ? n : NaN;
    }

    function isLikelyIntegerQuantityToken(tok) {
        const s = String(tok).replace(/\s/g, "");
        return /^\d{1,3}(,\d{3})*$/.test(s) || /^\d+$/.test(s);
    }

    function isLikelyPriceToken(tok) {
        const n = parseMoney(tok);
        return Number.isFinite(n) && n > 0 && n < 100000;
    }

    function findMarketPriceNearQuantity(parts) {
        for (let i = 1; i < parts.length - 1; i++) {
            const t = parts[i];
            if (!isLikelyIntegerQuantityToken(t)) continue;
            for (let j = i + 1; j < Math.min(i + 4, parts.length); j++) {
                const cand = parts[j];
                if (isLikelyPriceToken(cand)) {
                    const price = parseMoney(cand);
                    if (String(cand).includes("%")) continue;
                    return price;
                }
            }
        }
        return NaN;
    }

    function findEvaluareFromEnd(parts) {
        let hits = 0;
        let firstMoney = NaN;
        for (let i = parts.length - 1; i >= 0; i--) {
            const tok = String(parts[i] ?? "");
            if (tok.endsWith("%")) continue;
            const n = parseMoney(tok);
            if (!Number.isFinite(n)) continue;
            hits++;
            if (hits === 1) firstMoney = n;
            if (hits === 2) return n;
        }
        return firstMoney;
    }

    function findBestCashLike(parts) {
        let best = NaN;
        for (const p of parts) {
            const n = parseMoney(p);
            if (!Number.isFinite(n)) continue;
            if (!Number.isFinite(best) || n > best) best = n;
        }
        return best;
    }

    // ---- CSV parsing (as before) ----
    function detectDelimiter(headerLine) {
        const commaCount = (headerLine.match(/,/g) || []).length;
        const semiCount = (headerLine.match(/;/g) || []).length;
        const tabCount = (headerLine.match(/\t/g) || []).length;
        if (tabCount > commaCount && tabCount > semiCount) return "\t";
        if (semiCount > commaCount) return ";";
        return ",";
    }

    function splitCsvLine(line, delimiter) {
        const out = [];
        let cur = "";
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
            const ch = line[i];
            if (ch === '"') {
                const next = line[i + 1];
                if (inQuotes && next === '"') { cur += '"'; i++; }
                else inQuotes = !inQuotes;
                continue;
            }
            if (!inQuotes && ch === delimiter) { out.push(cur); cur = ""; continue; }
            cur += ch;
        }
        out.push(cur);
        return out.map(v => v.trim());
    }

    function toNumberMaybe(raw) {
        if (raw == null) return raw;
        const s = String(raw).trim();
        if (s === "") return s;
        const noPct = s.replace(/%/g, "").trim();
        const normalized = noPct.replace(/\s/g, "");
        const n = Number(normalized);
        if (!Number.isNaN(n)) return n;
        const commaDecimal = normalized.replace(",", ".");
        const n2 = Number(commaDecimal);
        if (!Number.isNaN(n2)) return n2;
        return s;
    }

    function normalizeHeader(h) {
        const s = String(h || "").trim().toLowerCase();
        if (s === "price") return "market_price";
        if (s === "marketprice") return "market_price";
        if (s === "market_price") return "market_price";
        if (s === "pret_piata") return "market_price";
        if (s === "pretpiata") return "market_price";
        return s;
    }

    function parseCSV(data) {
        const lines = data
            .replace(/\r\n/g, "\n")
            .replace(/\r/g, "\n")
            .split("\n")
            .map(l => l.trim())
            .filter(l => l !== "" && !l.startsWith("#"));
        if (lines.length === 0) return [];
        const delimiter = detectDelimiter(lines[0]);
        const rawHeaders = splitCsvLine(lines[0], delimiter).map(h => h.trim());
        const headers = rawHeaders.map(normalizeHeader);

        const rows = [];
        for (let i = 1; i < lines.length; i++) {
            const values = splitCsvLine(lines[i], delimiter);
            const obj = {};
            headers.forEach((h, idx) => { obj[h] = toNumberMaybe(values[idx] ?? ""); });
            rows.push(obj);
        }
        return rows;
    }

    function portfolioValues(rows) {
        const cleaned = rows
            .map(r => ({
                symbol: String(r.symbol ?? "").trim(),
                value: Number(r.value),
                market_price: r.market_price === "" ? "" : Number(r.market_price)
            }))
            .filter(r => r.symbol !== "" && Number.isFinite(r.value));

        const cashSymbols = new Set(["CASH_VALUE", "CASH", "CASH_RON", "RON"]);
        const cashRows = cleaned.filter(r => cashSymbols.has(r.symbol.toUpperCase()));
        const stockRows = cleaned.filter(r => !cashSymbols.has(r.symbol.toUpperCase()));

        const bad = stockRows.filter(r => !(Number.isFinite(Number(r.market_price)) && Number(r.market_price) > 0));
        if (bad.length > 0) throw new Error(`Missing or invalid market_price for: ${bad.map(b => b.symbol).join(", ")}`);

        const cashValue = cashRows.reduce((s, r) => s + r.value, 0);
        const totalStocksValue = stockRows.reduce((s, r) => s + r.value, 0);
        const totalAllValue = totalStocksValue + cashValue;
        if (totalStocksValue <= 0) throw new Error("Total stocks value is 0.");

        const portfolio = stockRows.map(r => ({
            symbol: r.symbol,
            value: r.value,
            market_price: Number(r.market_price),
            weight: (r.value / totalStocksValue) * 100
        }));

        return { portfolio, totalStocksValue, cashValue, totalAllValue, rawStocks: stockRows };
    }

    function formatZeroNoMinus(x) {
        if (Math.abs(x) < 0.005) return "0.00";
        return x.toFixed(2);
    }

    function computeFeeInfoForCards(totalRon, eurJson, feesJson) {
        try {
            const eurRon = Number(eurJson?.eur_ron);
            if (!Number.isFinite(eurRon) || eurRon <= 0) return null;
            const totalEur = totalRon / eurRon;
            const tier = pickTier(totalEur, feesJson);
            if (!tier) return null;

            return {
                eurRon,
                tierName: tier.name || null,
                feePercent: Number(tier.fee_percent ?? 0),
                fixedFeeEur: Number(tier.fixed_fee_eur ?? 0)
            };
        } catch {
            return null;
        }
    }

    // IMPORTANT: price is displayed as-is (no rounding)
    function buildSuggestionDetailsLine(it, feeInfo) {
        if (!it || !Number.isFinite(it.shares) || !Number.isFinite(it.price) || it.shares <= 0) return "";

        if (Number.isFinite(it.amountGross) && Number.isFinite(it.fee) && Number.isFinite(it.totalCost)) {
            if (!feeInfo || !Number.isFinite(feeInfo.eurRon)) {
                return `${it.shares} shares × ${it.price} ≈ ${it.amountGross.toFixed(2)}`;
            }
            return `${it.shares} shares × ${it.price} + ${it.fee.toFixed(2)} ≈ ${it.totalCost.toFixed(2)}`;
        }

        const gross = it.shares * it.price;
        if (!feeInfo || !Number.isFinite(feeInfo.eurRon)) {
            return `${it.shares} shares × ${it.price} ≈ ${gross.toFixed(2)}`;
        }
        const variableFee = gross * (feeInfo.feePercent / 100);
        const fixedFeeRon = feeInfo.fixedFeeEur * feeInfo.eurRon;
        const fee = variableFee + fixedFeeRon;
        return `${it.shares} shares × ${it.price} + ${fee.toFixed(2)} ≈ ${(gross + fee).toFixed(2)}`;
    }

    function generateReportAndSuggestions(
        bvbData,
        portfolioWithValues,
        totalStocksValue,
        totalAllValue,
        onlyPortfolioCompanies,
        newInvestment,
        minInvestmentAmount
    ) {
        const reportDiv = document.getElementById("report");
        const suggestionsDiv = document.getElementById("investmentSuggestions");
        const afterDiv = document.getElementById("afterSuggestions");

        suggestionsDiv.innerHTML = "";
        afterDiv.innerHTML = "";
        hideFeeTierSection();

        let bvbUniverse = bvbData;
        if (onlyPortfolioCompanies) {
            const owned = new Set(portfolioWithValues.map(p => p.symbol));
            bvbUniverse = bvbData.filter(b => owned.has(b.symbol));
        }

        const totalBvbWeight = bvbUniverse.reduce((sum, c) => sum + (Number(c.weight) || 0), 0);
        const normalizedBvb = bvbUniverse.map(c => ({
            symbol: c.symbol,
            bvbWeight: Number(c.weight) || 0,
            normalizedWeight: ((Number(c.weight) || 0) / totalBvbWeight) * 100
        }));

        let sumDiff = 0;
        const rowsHtml = normalizedBvb.map(c => {
            const p = portfolioWithValues.find(x => x.symbol === c.symbol);
            const pWeight = p ? p.weight : 0;

            const diffPercent = pWeight - c.normalizedWeight;
            const diffValue = (diffPercent / 100) * totalStocksValue;
            sumDiff += diffValue;

            const cls = diffValue >= 0 ? "positive-difference" : "negative-difference";

            return `
        <tr>
          <td>${c.symbol}</td>
          <td>${c.bvbWeight.toFixed(2)}%</td>
          <td>${c.normalizedWeight.toFixed(2)}%</td>
          <td>${pWeight.toFixed(2)}%</td>
          <td class="${cls}">${diffValue.toFixed(2)} (${diffPercent.toFixed(2)}%)</td>
        </tr>
      `;
        }).join("");

        reportDiv.innerHTML = `
      <h3>Portfolio Comparison</h3>
      <table>
        <tr>
          <th>Symbol</th>
          <th>BVB Weight</th>
          <th>Normalized BVB Weight</th>
          <th>Portfolio Weight</th>
          <th>Difference (Val and %)</th>
        </tr>
        ${rowsHtml}
      </table>
      <div style="margin-top:10px;" class="muted">
        Sanity check: Σ Difference ≈ <b>${formatZeroNoMinus(sumDiff)}</b>
      </div>
    `;

        if (!(newInvestment > 0)) return;

        const feeInfo = computeFeeInfoForCards(totalAllValue, metaEurRon, metaFees);

        // Fee tier block first (best effort)
        if (metaEurRon && metaFees) {
            try {
                renderFeeTierSection(totalAllValue, metaEurRon, metaFees);
                suggestionsDiv.appendChild(feeTierBlockEl);
            } catch (e) {
                console.warn("Fee tier render failed:", e);
                hideFeeTierSection();
            }
        }

        const suggestions = computeSuggestionsWithMarketPrices(
            normalizedBvb,
            portfolioWithValues,
            totalStocksValue,
            newInvestment,
            minInvestmentAmount,
            feeInfo
        );

        const allocatedTotal = suggestions.investedTotal ?? suggestions.items.reduce((s, it) => s + (it.totalCost ?? it.amount), 0);
        const allocatedGross = suggestions.investedGross ?? suggestions.items.reduce((s, it) => s + (it.amountGross ?? it.amount), 0);
        const unallocated = suggestions.unallocated;

        const unallocCls = unallocated < -0.005 ? "neg" : "";

        const listItems = suggestions.items.map(it => {
            const detailsLine = buildSuggestionDetailsLine(it, feeInfo);
            return `
        <li>
          <div class="investment-symbol">${it.symbol}</div>
          <div class="investment-amount">${(Number.isFinite(it.totalCost) ? it.totalCost : it.amount).toFixed(2)}</div>
          ${detailsLine ? `<div class="suggestion-details">${detailsLine}</div>` : ``}
        </li>
      `;
        }).join("");

        const feeTierHtml = suggestionsDiv.innerHTML;

        suggestionsDiv.innerHTML = `
      <h3>Investment Suggestions</h3>
      ${feeTierHtml}
      <div class="total-investment">
        Available: ${newInvestment.toFixed(2)}
        · Allocated: ${allocatedTotal.toFixed(2)}
        · Unallocated: <span class="${unallocCls}">${formatZeroNoMinus(unallocated)}</span>
      </div>
      <div class="muted" style="margin-top:6px;">
        Allocated includes estimated fees per symbol (variable + fixed). Gross-only invested: ${allocatedGross.toFixed(2)}.
      </div>
      <ul>${listItems}</ul>
      <div class="muted" style="margin-top:10px;">
        Notes: Suggestions are constrained by market prices (whole shares). Fees shown are estimates.
      </div>
    `;

        const after = portfolioAfterSuggestions(
            portfolioWithValues,
            suggestions.items.map(it => ({ symbol: it.symbol, amount: (it.amountGross ?? it.amount), shares: it.shares, price: it.price })),
            totalStocksValue
        );

        renderAfterSuggestionsTable(afterDiv, normalizedBvb, after, totalStocksValue, suggestions);
    }

    // ✅ Objective-based greedy + sweep-to-spend + fee-aware + min-per-stock respected when opening new symbols
    function computeSuggestionsWithMarketPrices(
        normalizedBvb,
        portfolioWithValues,
        totalStocksValue,
        cashToInvest,
        minPerStock,
        feeInfo
    ) {
        const currentBySymbol = new Map(portfolioWithValues.map(p => [p.symbol, p]));
        const targets = normalizedBvb.map(c => ({ symbol: c.symbol, t: c.normalizedWeight / 100 }));

        const T0 = totalStocksValue;
        const cash0 = cashToInvest;

        const feePct = (feeInfo && Number.isFinite(feeInfo.feePercent)) ? (feeInfo.feePercent / 100) : 0;
        const fixedRon =
            (feeInfo && Number.isFinite(feeInfo.fixedFeeEur) && Number.isFinite(feeInfo.eurRon))
                ? (feeInfo.fixedFeeEur * feeInfo.eurRon)
                : 0;

        const minGross = Number.isFinite(minPerStock) && minPerStock > 0 ? minPerStock : 0;

        // universe: symbols with valid market price
        const universe = [];
        for (const x of targets) {
            const p = currentBySymbol.get(x.symbol);
            const price = p ? Number(p.market_price) : NaN;
            if (!Number.isFinite(price) || price <= 0) continue;
            universe.push({
                symbol: x.symbol,
                target: x.t,
                price,
                baseValue: p ? Number(p.value) : 0
            });
        }
        if (universe.length === 0) return { items: [], unallocated: cash0, investedGross: 0, investedTotal: 0 };

        const bySym = new Map(universe.map(u => [u.symbol, u]));

        // state per symbol
        const st = new Map();
        for (const u of universe) st.set(u.symbol, { shares: 0, gross: 0 });

        function feeFor(gross, shares) {
            if (shares <= 0) return 0;
            return gross * feePct + fixedRon;
        }
        function totalCostFor(gross, shares) {
            return gross + feeFor(gross, shares);
        }

        function currentTotalGrossInvested() {
            let s = 0;
            for (const v of st.values()) s += v.gross;
            return s;
        }
        function currentTotalCostInvested() {
            let s = 0;
            for (const u of universe) {
                const v = st.get(u.symbol);
                s += totalCostFor(v.gross, v.shares);
            }
            return s;
        }

        // If opening a new symbol (shares=0), ensure we can reach minGross for that symbol
        // within current cashRemaining (including fees).
        function canOpenSymbolWithMin(sym, cashRemaining) {
            if (minGross <= 0) return true;
            const u = bySym.get(sym);
            if (!u) return false;
            const reqShares = Math.ceil(minGross / u.price);
            const reqGross = reqShares * u.price;
            const reqTotal = totalCostFor(reqGross, reqShares); // includes fixed fee once
            return reqTotal <= cashRemaining + 1e-9;
        }

        function evalBuyOne(sym) {
            const u = bySym.get(sym);
            if (!u) return null;

            const cur = st.get(sym);
            const nextShares = cur.shares + 1;
            const nextGross = cur.gross + u.price;

            const prevCost = totalCostFor(cur.gross, cur.shares);
            const nextCost = totalCostFor(nextGross, nextShares);
            const deltaCost = nextCost - prevCost;

            const investedGross = currentTotalGrossInvested();
            const T_before = T0 + investedGross;
            const T_after  = T_before + u.price;

            let delta = 0;
            for (const uu of universe) {
                const vv = st.get(uu.symbol);
                const grossBefore = vv.gross;
                const grossAfter  = vv.gross + (uu.symbol === sym ? u.price : 0);

                const newValBefore = uu.baseValue + grossBefore;
                const newValAfter  = uu.baseValue + grossAfter;

                const wBefore = newValBefore / T_before;
                const wAfter  = newValAfter  / T_after;

                const errBefore = wBefore - uu.target;
                const errAfter  = wAfter  - uu.target;

                delta += (errAfter * errAfter) - (errBefore * errBefore);
            }

            return { deltaObj: delta, deltaCost };
        }

        function buyOne(sym) {
            const u = bySym.get(sym);
            const cur = st.get(sym);
            cur.shares += 1;
            cur.gross += u.price;
        }

        // Greedy pass: only take improvements (deltaObj < 0)
        function runGreedy(disallowNewSymbolsSet) {
            let guard = 0;
            while (guard++ < 200000) {
                const spent = currentTotalCostInvested();
                const cashRemaining = cash0 - spent;
                if (cashRemaining < 0.01) break;

                let bestSym = null;
                let bestDelta = 0; // need negative

                for (const u of universe) {
                    const cur = st.get(u.symbol);

                    if (disallowNewSymbolsSet && cur.shares === 0 && disallowNewSymbolsSet.has(u.symbol)) continue;

                    // if this buy would open a symbol, ensure we can reach minGross overall for that symbol
                    if (cur.shares === 0 && !canOpenSymbolWithMin(u.symbol, cashRemaining)) continue;

                    const ev = evalBuyOne(u.symbol);
                    if (!ev) continue;
                    if (ev.deltaCost > cashRemaining + 1e-9) continue;

                    if (ev.deltaObj < bestDelta) {
                        bestDelta = ev.deltaObj;
                        bestSym = u.symbol;
                    }
                }

                if (!bestSym) break;
                buyOne(bestSym);
            }
        }

        // Sweep pass: spend remaining cash, choose least-bad deltaObj (smallest), while respecting fees/min/open constraints
        function runSweep(disallowNewSymbolsSet) {
            let guard = 0;
            while (guard++ < 200000) {
                const spent = currentTotalCostInvested();
                const cashRemaining = cash0 - spent;
                if (cashRemaining < 0.01) break;

                let bestSym = null;
                let bestDelta = Infinity;
                let bestDeltaCost = -Infinity; // tie-break: spend more

                for (const u of universe) {
                    const cur = st.get(u.symbol);

                    if (disallowNewSymbolsSet && cur.shares === 0 && disallowNewSymbolsSet.has(u.symbol)) continue;

                    // if opening a new symbol during sweep, ensure we can actually satisfy minGross for that symbol
                    if (cur.shares === 0 && !canOpenSymbolWithMin(u.symbol, cashRemaining)) continue;

                    const ev = evalBuyOne(u.symbol);
                    if (!ev) continue;
                    if (ev.deltaCost > cashRemaining + 1e-9) continue;

                    if (
                        ev.deltaObj < bestDelta - 1e-15 ||
                        (Math.abs(ev.deltaObj - bestDelta) <= 1e-15 && ev.deltaCost > bestDeltaCost)
                    ) {
                        bestDelta = ev.deltaObj;
                        bestDeltaCost = ev.deltaCost;
                        bestSym = u.symbol;
                    }
                }

                if (!bestSym) break;
                buyOne(bestSym);
            }
        }

        // 1) optimize tracking (improving moves only)
        runGreedy(null);

        // 2) soft-min: drop positions below minGross, rerun greedy without reopening those
        let dropped = null;
        if (minGross > 0) {
            const toDrop = new Set();
            for (const u of universe) {
                const cur = st.get(u.symbol);
                if (cur.shares > 0 && cur.gross + 1e-9 < minGross) toDrop.add(u.symbol);
            }
            if (toDrop.size > 0) {
                for (const sym of toDrop) st.set(sym, { shares: 0, gross: 0 });
                runGreedy(toDrop);
                dropped = toDrop;
            }
        }

        // 3) spend remaining cash with minimal damage, still respecting min-per-stock when opening new symbols
        runSweep(dropped);

        // Build items
        const items = [];
        let spentTotal = 0;
        let spentGross = 0;

        for (const u of universe) {
            const cur = st.get(u.symbol);
            if (cur.shares <= 0) continue;

            // (should already be true, but keep safe)
            if (minGross > 0 && cur.gross + 1e-9 < minGross) continue;

            const fee = feeFor(cur.gross, cur.shares);
            const totalCost = cur.gross + fee;

            items.push({
                symbol: u.symbol,
                shares: cur.shares,
                price: u.price,
                amountGross: cur.gross,
                fee,
                totalCost,
                amount: cur.gross
            });

            spentTotal += totalCost;
            spentGross += cur.gross;
        }

        const unallocated = Math.max(0, cash0 - spentTotal);
        return { items, unallocated, investedGross: spentGross, investedTotal: spentTotal };
    }

    function portfolioAfterSuggestions(portfolioWithValues, items, totalStocksValue) {
        const map = new Map(portfolioWithValues.map(p => [p.symbol, { ...p }]));
        for (const it of items) {
            const existing = map.get(it.symbol);
            if (existing) existing.value += it.amount;
            else map.set(it.symbol, { symbol: it.symbol, value: it.amount, weight: 0, market_price: NaN });
        }
        const invested = items.reduce((s, it) => s + it.amount, 0);
        const newTotal = totalStocksValue + invested;

        const list = Array.from(map.values()).map(p => ({
            symbol: p.symbol,
            value: p.value,
            weight: (p.value / newTotal) * 100
        }));

        return { list, newTotal, invested };
    }

    function renderAfterSuggestionsTable(afterDiv, normalizedBvb, after, oldTotalStocksValue, suggestions) {
        const { list, newTotal, invested } = after;
        const newW = new Map(list.map(x => [x.symbol, x.weight]));

        const rows = normalizedBvb.map(c => {
            const wNew = newW.get(c.symbol) || 0;
            const diffNewPct = wNew - c.normalizedWeight;
            const diffNewVal = (diffNewPct / 100) * newTotal;
            const cls = diffNewVal >= 0 ? "positive-difference" : "negative-difference";

            return `
        <tr>
          <td>${c.symbol}</td>
          <td>${c.normalizedWeight.toFixed(2)}%</td>
          <td>${wNew.toFixed(2)}%</td>
          <td class="${cls}">${diffNewVal.toFixed(2)} (${diffNewPct.toFixed(2)}%)</td>
        </tr>
      `;
        }).join("");

        afterDiv.innerHTML = `
      <div class="spacer-24"></div>
      <h3>Portfolio after applying suggestions</h3>
      <div class="muted" style="margin-bottom:10px;">
        New stocks total: <b>${newTotal.toFixed(2)}</b> (old: ${oldTotalStocksValue.toFixed(2)}) ·
        Invested (gross): <b>${invested.toFixed(2)}</b> ·
        Unallocated: <b>${suggestions.unallocated.toFixed(2)}</b>
      </div>
      <table>
        <tr>
          <th>Symbol</th>
          <th>Normalized BVB Weight</th>
          <th>New Portfolio Weight</th>
          <th>New Difference (Val and %)</th>
        </tr>
        ${rows}
      </table>
    `;
    }
</script>

</body>
</html>
