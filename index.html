<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>BVB Portfolio Tracker</title>
    <link rel="stylesheet" href="styles.css" />
    <style>
        /* Make readonly inputs clearly non-editable */
        input[readonly] {
            background-color: #eee;
            color: #666;
            cursor: not-allowed;
        }

        .muted { font-size: 13px; color: #666; }
        .spacer-16 { height: 16px; }
        .spacer-24 { height: 24px; }
    </style>
</head>
<body>

<!-- Top navigation -->
<div class="top-nav">
    <div class="top-nav-inner">
        <div class="top-nav-title">BVB Index Distribution</div>
        <div class="top-nav-tabs">
            <a class="top-nav-tab active" href="index.html">Tracker</a>
            <a class="top-nav-tab" href="about.html">About</a>
            <a class="top-nav-tab" href="data.html">Data Coverage</a>
        </div>
    </div>
</div>

<h2>BVB Portfolio Tracker</h2>

<div class="container">

    <!-- BVB CSV Source (auto) -->
    <div class="file-input section">
        <label>BVB Companies CSV</label>
        <div class="file-wrapper" style="justify-content: space-between;">
            <span class="file-name" id="bvbSourceStatus">
                Using latest from repository: <b>bvb-companies-latest.csv</b>
            </span>
            <a
                    href="input/bvb_distribution/bvb-companies-latest.csv"
                    class="file-label"
                    style="text-decoration: none; display: inline-block;"
                    target="_blank"
                    rel="noopener noreferrer"
            >
                Open latest
            </a>
        </div>
        <div style="margin-top: 8px;" class="muted">
            Status: <span id="bvbLoadStatus">Will be loaded on Generate Report</span>
        </div>
    </div>

    <!-- Portfolio CSV -->
    <div class="file-input section">
        <label for="portfolioFile">Upload Current Portfolio CSV (symbol,value)</label>
        <div class="file-wrapper">
            <label for="portfolioFile" class="file-label">Choose file</label>
            <input type="file" id="portfolioFile" accept=".csv,.txt" />
            <span class="file-name" id="portfolioFileName">No file chosen</span>
        </div>
        <div style="margin-top: 8px;" class="muted">
            Expected headers: <b>symbol,value</b>. Use <b>CASH_VALUE</b> row for available cash
            (e.g. <code>CASH_VALUE,12023.80</code>).
        </div>
        <div style="margin-top: 6px;" class="muted">
            Detected: <span id="portfolioParseStatus">No file loaded</span>
        </div>
    </div>

    <!-- Total Portfolio Value (stocks-only) -->
    <div class="input-group section">
        <label for="totalInvestment">Total Portfolio Value (stocks-only, auto from CSV)</label>
        <input
                type="number"
                id="totalInvestment"
                placeholder="Auto-filled from portfolio CSV"
                readonly
        />
        <div style="margin-top: 6px;" class="muted">
            This excludes CASH_VALUE so cash won’t influence stock weights.
        </div>
    </div>

    <!-- Filter Portfolio Toggle -->
    <div class="toggle-container section">
        <label for="filterPortfolioToggle">Only consider companies in my portfolio</label>
        <input type="checkbox" id="filterPortfolioToggle" checked />
    </div>

    <!-- New Investment Toggle -->
    <div class="toggle-container section">
        <label for="newInvestmentToggle">Enable New Investment</label>
        <input type="checkbox" id="newInvestmentToggle" />
    </div>

    <!-- New Investment Inputs -->
    <div id="investmentFields" style="display: none;" class="section">
        <div class="input-group">
            <label for="newInvestmentAmount">New Investment Amount (auto from CASH_VALUE)</label>
            <input type="number" id="newInvestmentAmount" placeholder="Enter new investment amount" />
        </div>

        <div class="input-group">
            <label for="minInvestmentAmount">Minimum Investment per Stock</label>
            <input type="number" id="minInvestmentAmount" placeholder="Enter minimum investment per stock" value="500" />
        </div>

        <div class="muted">Suggestions are rounded down to <b>50</b> so total never exceeds available cash.</div>
        <div class="spacer-16"></div>
    </div>

    <button id="generateReport">Generate Report</button>

    <div class="report-container">
        <div id="report"></div>
        <div id="investmentSuggestions"></div>
        <div id="afterSuggestions"></div>
    </div>
</div>

<script>
    const BVB_LATEST_CSV_URL = "input/bvb_distribution/bvb-companies-latest.csv";

    // Round allocation lots to this amount (RON, or your chosen base currency)
    const SUGGESTION_ROUND_STEP = 50;

    const bvbLoadStatusEl = document.getElementById("bvbLoadStatus");
    const portfolioParseStatusEl = document.getElementById("portfolioParseStatus");
    const totalInvestmentEl = document.getElementById("totalInvestment");
    const newInvestmentAmountEl = document.getElementById("newInvestmentAmount");

    let parsedPortfolio = null;

    document.getElementById("newInvestmentToggle").addEventListener("change", function () {
        document.getElementById("investmentFields").style.display = this.checked ? "block" : "none";
    });

    document.getElementById("portfolioFile").addEventListener("change", function () {
        const file = this.files[0];
        document.getElementById("portfolioFileName").textContent = file ? file.name : "No file chosen";

        parsedPortfolio = null;
        portfolioParseStatusEl.textContent = "Parsing...";
        totalInvestmentEl.value = "";
        newInvestmentAmountEl.value = "";

        if (!file) {
            portfolioParseStatusEl.textContent = "No file loaded";
            return;
        }

        const reader = new FileReader();
        reader.onload = function (event) {
            try {
                const rows = parseCSV(event.target.result);

                const hasValue = rows.length > 0 && Object.prototype.hasOwnProperty.call(rows[0], "value");
                if (!hasValue) throw new Error("Portfolio CSV must contain headers: symbol,value");

                const { portfolio, totalStocksValue, cashValue, totalAllValue } = portfolioValues(rows);

                parsedPortfolio = { portfolio, totalStocksValue, cashValue, totalAllValue };

                totalInvestmentEl.value = totalStocksValue.toFixed(2);

                if (cashValue > 0) {
                    newInvestmentAmountEl.value = cashValue.toFixed(2);
                    portfolioParseStatusEl.textContent =
                        `Loaded ✅ (stocks: ${totalStocksValue.toFixed(2)}, CASH_VALUE: ${cashValue.toFixed(2)})`;
                } else {
                    portfolioParseStatusEl.textContent =
                        `Loaded ✅ (stocks: ${totalStocksValue.toFixed(2)}, no CASH_VALUE row found)`;
                }
            } catch (e) {
                console.error(e);
                portfolioParseStatusEl.textContent = "Failed ❌";
                alert(`Could not parse portfolio CSV: ${e.message}`);
            }
        };
        reader.readAsText(file);
    });

    document.getElementById("generateReport").addEventListener("click", async function () {
        if (!parsedPortfolio) {
            alert("Please upload the portfolio file (symbol,value).");
            return;
        }

        const onlyPortfolioCompanies = document.getElementById("filterPortfolioToggle").checked;

        const totalStocksValue = Number(totalInvestmentEl.value);
        if (!Number.isFinite(totalStocksValue) || totalStocksValue <= 0) {
            alert("Total Portfolio Value (stocks-only) is missing or invalid.");
            return;
        }

        const newInvestmentEnabled = document.getElementById("newInvestmentToggle").checked;
        const newInvestment = newInvestmentEnabled ? Number(document.getElementById("newInvestmentAmount").value) : 0;
        const minInvestmentAmount = newInvestmentEnabled ? Number(document.getElementById("minInvestmentAmount").value) : 0;

        if (newInvestmentEnabled && (!Number.isFinite(newInvestment) || newInvestment <= 0)) {
            alert("Please enter a valid New Investment Amount.");
            return;
        }
        if (newInvestmentEnabled && (!Number.isFinite(minInvestmentAmount) || minInvestmentAmount < 0)) {
            alert("Please enter a valid Minimum Investment per Stock.");
            return;
        }

        // Load BVB latest CSV on demand
        bvbLoadStatusEl.textContent = "Loading...";
        let bvbText;
        try {
            const cacheBuster = `t=${Date.now()}`;
            const resp = await fetch(`${BVB_LATEST_CSV_URL}?${cacheBuster}`, { cache: "no-store" });
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            bvbText = await resp.text();
            bvbLoadStatusEl.textContent = "Loaded ✅";
        } catch (e) {
            console.error(e);
            bvbLoadStatusEl.textContent = "Failed ❌";
            alert("Could not load the latest BVB companies file from the repository.");
            return;
        }

        const bvbData = parseCSV(bvbText);

        generateReportAndSuggestions(
            bvbData,
            parsedPortfolio.portfolio,
            parsedPortfolio.totalStocksValue,
            onlyPortfolioCompanies,
            newInvestmentEnabled ? newInvestment : 0,
            newInvestmentEnabled ? minInvestmentAmount : 0
        );
    });

    // ----------------------------
    // CSV parsing (comma/semicolon/tab + basic quoting)
    // ----------------------------
    function detectDelimiter(headerLine) {
        const commaCount = (headerLine.match(/,/g) || []).length;
        const semiCount = (headerLine.match(/;/g) || []).length;
        const tabCount = (headerLine.match(/\t/g) || []).length;

        if (tabCount > commaCount && tabCount > semiCount) return "\t";
        if (semiCount > commaCount) return ";";
        return ",";
    }

    function splitCsvLine(line, delimiter) {
        const out = [];
        let cur = "";
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
            const ch = line[i];

            if (ch === '"') {
                const next = line[i + 1];
                if (inQuotes && next === '"') {
                    cur += '"';
                    i++;
                } else {
                    inQuotes = !inQuotes;
                }
                continue;
            }

            if (!inQuotes && ch === delimiter) {
                out.push(cur);
                cur = "";
                continue;
            }

            cur += ch;
        }
        out.push(cur);
        return out.map(v => v.trim());
    }

    function toNumberMaybe(raw) {
        if (raw == null) return raw;
        const s = String(raw).trim();
        if (s === "") return s;

        const noPct = s.replace(/%/g, "").trim();
        const normalized = noPct.replace(/\s/g, "");
        const n = Number(normalized);
        if (!Number.isNaN(n)) return n;

        const commaDecimal = normalized.replace(",", ".");
        const n2 = Number(commaDecimal);
        if (!Number.isNaN(n2)) return n2;

        return s;
    }

    function parseCSV(data) {
        const lines = data
            .replace(/\r\n/g, "\n")
            .replace(/\r/g, "\n")
            .split("\n")
            .map(l => l.trim())
            .filter(l => l !== "" && !l.startsWith("#"));

        if (lines.length === 0) return [];

        const delimiter = detectDelimiter(lines[0]);
        const headers = splitCsvLine(lines[0], delimiter).map(h => h.trim());

        const rows = [];
        for (let i = 1; i < lines.length; i++) {
            const values = splitCsvLine(lines[i], delimiter);

            const obj = {};
            headers.forEach((h, idx) => {
                obj[h] = toNumberMaybe(values[idx] ?? "");
            });

            // Header normalization
            if (obj.Symbol && !obj.symbol) obj.symbol = obj.Symbol;
            if (obj.VALUE && !obj.value) obj.value = obj.VALUE;

            rows.push(obj);
        }
        return rows;
    }

    // ----------------------------
    // Portfolio values -> weights (stocks-only)
    // ----------------------------
    function portfolioValues(rows) {
        const cleaned = rows
            .map(r => ({
                symbol: String(r.symbol ?? "").trim(),
                value: Number(r.value)
            }))
            .filter(r => r.symbol !== "" && Number.isFinite(r.value));

        const cashSymbols = new Set(["CASH_VALUE", "CASH", "CASH_RON", "RON"]);
        const cashRows = cleaned.filter(r => cashSymbols.has(r.symbol.toUpperCase()));
        const stockRows = cleaned.filter(r => !cashSymbols.has(r.symbol.toUpperCase()));

        const cashValue = cashRows.reduce((s, r) => s + r.value, 0);
        const totalStocksValue = stockRows.reduce((s, r) => s + r.value, 0);
        const totalAllValue = totalStocksValue + cashValue;

        if (totalStocksValue <= 0) throw new Error("Total stocks value is 0.");

        const portfolio = stockRows.map(r => ({
            symbol: r.symbol,
            value: r.value,
            weight: (r.value / totalStocksValue) * 100
        }));

        return { portfolio, totalStocksValue, cashValue, totalAllValue };
    }

    function formatZeroNoMinus(x) {
        // Avoid displaying "-0.00"
        if (Math.abs(x) < 0.005) return "0.00";
        return x.toFixed(2);
    }

    // ----------------------------
    // Main report + suggestions + simulation table
    // ----------------------------
    function generateReportAndSuggestions(
        bvbData,
        portfolioWithValues,
        totalStocksValue,
        onlyPortfolioCompanies,
        newInvestment,
        minInvestmentAmount
    ) {
        const reportDiv = document.getElementById("report");
        const suggestionsDiv = document.getElementById("investmentSuggestions");
        const afterDiv = document.getElementById("afterSuggestions");

        suggestionsDiv.innerHTML = "";
        afterDiv.innerHTML = "";

        // Determine the BVB universe to compare against
        let bvbUniverse = bvbData;
        if (onlyPortfolioCompanies) {
            const owned = new Set(portfolioWithValues.map(p => p.symbol));
            bvbUniverse = bvbData.filter(b => owned.has(b.symbol));
        }

        // Normalize BVB weights to 100% for the current universe
        const totalBvbWeight = bvbUniverse.reduce((sum, c) => sum + (Number(c.weight) || 0), 0);
        const normalizedBvb = bvbUniverse.map(c => ({
            symbol: c.symbol,
            bvbWeight: Number(c.weight) || 0,
            normalizedWeight: ((Number(c.weight) || 0) / totalBvbWeight) * 100
        }));

        // Render comparison table and compute sum of diffs as a sanity check
        let sumDiff = 0;
        const rowsHtml = normalizedBvb.map(c => {
            const p = portfolioWithValues.find(x => x.symbol === c.symbol);
            const pWeight = p ? p.weight : 0;

            const diffPercent = pWeight - c.normalizedWeight;
            const diffValue = (diffPercent / 100) * totalStocksValue;
            sumDiff += diffValue;

            const cls = diffValue >= 0 ? "positive-difference" : "negative-difference";

            return `
                <tr>
                    <td>${c.symbol}</td>
                    <td>${c.bvbWeight.toFixed(2)}%</td>
                    <td>${c.normalizedWeight.toFixed(2)}%</td>
                    <td>${pWeight.toFixed(2)}%</td>
                    <td class="${cls}">${diffValue.toFixed(2)} (${diffPercent.toFixed(2)}%)</td>
                </tr>
            `;
        }).join("");

        reportDiv.innerHTML = `
            <h3>Portfolio Comparison</h3>
            <table>
                <tr>
                    <th>Symbol</th>
                    <th>BVB Weight</th>
                    <th>Normalized BVB Weight</th>
                    <th>Portfolio Weight</th>
                    <th>Difference (Val and %)</th>
                </tr>
                ${rowsHtml}
            </table>
            <div style="margin-top: 10px;" class="muted">
                Sanity check: Σ Difference ≈ <b>${formatZeroNoMinus(sumDiff)}</b>
            </div>
        `;

        if (!(newInvestment > 0)) return;

        const suggestions = computeSuggestions(
            normalizedBvb,
            portfolioWithValues,
            totalStocksValue,
            newInvestment,
            minInvestmentAmount,
            SUGGESTION_ROUND_STEP
        );

        const allocated = suggestions.items.reduce((s, x) => s + x.amount, 0);

        // Render suggestion cards
        const listItems = suggestions.items.map(it => `
            <li>
                <div class="investment-symbol">${it.symbol}</div>
                <div class="investment-amount">${it.amount.toFixed(2)}</div>
            </li>
        `).join("");

        suggestionsDiv.innerHTML = `
            <h3>Investment Suggestions</h3>
            <div class="total-investment">
                Available: ${newInvestment.toFixed(2)} · Allocated: ${allocated.toFixed(2)} · Unallocated: ${suggestions.unallocated.toFixed(2)}
            </div>
            <ul>
                ${listItems}
            </ul>
        `;

        // Simulate portfolio after applying suggestions
        const after = portfolioAfterSuggestions(portfolioWithValues, suggestions.items, totalStocksValue);
        renderAfterSuggestionsTable(afterDiv, normalizedBvb, after, totalStocksValue, suggestions);
    }

    // ----------------------------
    // Suggestion algorithm (buy-only)
    // ----------------------------
    function computeSuggestions(normalizedBvb, portfolioWithValues, totalStocksValue, cashToInvest, minPerStock, roundStep) {
        const currentValueBySymbol = new Map(portfolioWithValues.map(p => [p.symbol, p.value]));

        // Target weights as fractions
        const targets = normalizedBvb.map(c => ({
            symbol: c.symbol,
            t: c.normalizedWeight / 100
        }));

        // Compute positive gaps to reach target if we can only buy (no selling)
        const V = totalStocksValue;
        const C = cashToInvest;

        const gaps = targets.map(x => {
            const v = currentValueBySymbol.get(x.symbol) || 0;
            const desired = (V + C) * x.t;
            const gap = Math.max(0, desired - v);
            return { symbol: x.symbol, gap };
        });

        const totalGap = gaps.reduce((s, g) => s + g.gap, 0);
        if (totalGap <= 0) return { items: [], unallocated: C };

        // Proportional allocation
        let allocations = gaps.map(g => ({ symbol: g.symbol, amount: (g.gap / totalGap) * C }));

        // Minimum per stock (iteratively remove too-small allocations and redistribute)
        allocations = enforceMinimum(allocations, C, minPerStock);

        // Round down to steps and then distribute leftover steps without exceeding cash
        allocations = roundAllocationsDownAndDistribute(allocations, C, roundStep);

        const allocatedSum = allocations.reduce((s, a) => s + a.amount, 0);
        const unallocated = Math.max(0, C - allocatedSum);

        return {
            items: allocations.filter(a => a.amount > 0),
            unallocated
        };
    }

    function enforceMinimum(allocations, totalCash, minPerStock) {
        if (!minPerStock || minPerStock <= 0) return allocations;

        // If total cash can't meet the minimum, allocate everything to the top candidate
        if (totalCash < minPerStock) {
            const max = allocations.reduce((best, a) => (a.amount > best.amount ? a : best), allocations[0]);
            return allocations.map(a => ({ symbol: a.symbol, amount: a.symbol === max.symbol ? totalCash : 0 }));
        }

        let active = allocations.slice();

        while (true) {
            const small = active.filter(a => a.amount > 0 && a.amount < minPerStock);
            if (small.length === 0) break;

            const smallSum = small.reduce((s, a) => s + a.amount, 0);
            active = active.map(a => (a.amount < minPerStock ? { ...a, amount: 0 } : a));

            const remaining = active.filter(a => a.amount > 0);
            if (remaining.length === 0) return active;

            const remSum = remaining.reduce((s, a) => s + a.amount, 0);

            active = active.map(a => {
                if (a.amount <= 0) return a;
                const extra = (a.amount / remSum) * smallSum;
                return { ...a, amount: a.amount + extra };
            });
        }

        // Normalize to avoid float drift
        const sum = active.reduce((s, a) => s + a.amount, 0);
        const scale = sum > 0 ? (totalCash / sum) : 1;
        return active.map(a => ({ ...a, amount: a.amount * scale }));
    }

    function roundAllocationsDownAndDistribute(allocations, totalCash, step) {
        if (!step || step <= 1) return allocations;

        // 1) Round down so the sum never exceeds totalCash
        let rounded = allocations.map(a => ({
            symbol: a.symbol,
            amount: a.amount > 0 ? Math.floor(a.amount / step) * step : 0
        }));

        // 2) Distribute leftover in +step chunks, still never exceeding totalCash
        let sum = rounded.reduce((s, a) => s + a.amount, 0);
        let leftover = totalCash - sum;

        if (leftover < step) return rounded;

        // Add to the largest allocations first
        const order = rounded
            .map((a, idx) => ({ ...a, idx }))
            .filter(a => a.amount > 0)
            .sort((a, b) => b.amount - a.amount);

        if (order.length === 0) return rounded;

        let i = 0;
        while (leftover >= step - 0.0001) {
            const target = order[i % order.length];
            rounded[target.idx].amount += step;
            leftover -= step;
            i++;

            // Safety guard in case of floating point drift
            const checkSum = rounded.reduce((s2, x) => s2 + x.amount, 0);
            if (checkSum > totalCash + 0.0001) {
                rounded[target.idx].amount -= step;
                break;
            }
        }

        return rounded;
    }

    // ----------------------------
    // After-suggestions simulation
    // ----------------------------
    function portfolioAfterSuggestions(portfolioWithValues, items, totalStocksValue) {
        const map = new Map(portfolioWithValues.map(p => [p.symbol, { ...p }]));

        for (const it of items) {
            const existing = map.get(it.symbol);
            if (existing) {
                existing.value += it.amount;
            } else {
                map.set(it.symbol, { symbol: it.symbol, value: it.amount, weight: 0 });
            }
        }

        const invested = items.reduce((s, it) => s + it.amount, 0);
        const newTotal = totalStocksValue + invested;

        const list = Array.from(map.values()).map(p => ({
            symbol: p.symbol,
            value: p.value,
            weight: (p.value / newTotal) * 100
        }));

        return { list, newTotal, invested };
    }

    function renderAfterSuggestionsTable(afterDiv, normalizedBvb, after, oldTotalStocksValue, suggestions) {
        const { list, newTotal, invested } = after;

        const newW = new Map(list.map(x => [x.symbol, x.weight]));

        const rows = normalizedBvb.map(c => {
            const wNew = newW.get(c.symbol) || 0;
            const diffNewPct = wNew - c.normalizedWeight;
            const diffNewVal = (diffNewPct / 100) * newTotal;
            const cls = diffNewVal >= 0 ? "positive-difference" : "negative-difference";

            return `
                <tr>
                    <td>${c.symbol}</td>
                    <td>${c.normalizedWeight.toFixed(2)}%</td>
                    <td>${wNew.toFixed(2)}%</td>
                    <td class="${cls}">${diffNewVal.toFixed(2)} (${diffNewPct.toFixed(2)}%)</td>
                </tr>
            `;
        }).join("");

        afterDiv.innerHTML = `
            <div class="spacer-24"></div>
            <h3>Portfolio after applying suggestions</h3>
            <div class="muted" style="margin-bottom: 10px;">
                New stocks total: <b>${newTotal.toFixed(2)}</b> (old: ${oldTotalStocksValue.toFixed(2)}) ·
                Invested: <b>${invested.toFixed(2)}</b> ·
                Unallocated: <b>${suggestions.unallocated.toFixed(2)}</b>
            </div>
            <table>
                <tr>
                    <th>Symbol</th>
                    <th>Normalized BVB Weight</th>
                    <th>New Portfolio Weight</th>
                    <th>New Difference (Val and %)</th>
                </tr>
                ${rows}
            </table>
        `;
    }
</script>

</body>
</html>
